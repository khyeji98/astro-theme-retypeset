---
title: 동시성 다이브 - 1. GCD 이전
published: 2026-01-05
tags:
  - iOS
toc: false
lang: ko
abbrlink : before-gcd
---

앱이 복잡해지면서 메인 스레드 하나로 모든 작업을 처리하는 데에는 한계가 생기고, 백그라운드 스레드가 필요하기 때문에 GCD 이전에는 직접 스레드를 생성하고 제어해야 했습니다.
  
이 방식으로 인해 발생할 수 있는 문제들이 있습니다.
  
1. **스레드 폭발** : 너무 많은 스레드를 생성하면 크래시가 발생할 수 있습니다.
2. **동기화 지옥** : 여러 스레드가 변수 하나를 건드릴 때마다, 직접 Lock을 했다가 풀었다가 해야합니다.
3. **UI 업데이트의 번거로움** : 백그라운드 스레드에서 작업하다가 UI 업데이트 작업은 메인 스레드에서 동작하게끔 전환해야 하는 번거로움이 있습니다.
  
위 문제들 뿐만 아니라 **스레드는 작업마다 생성하고 제거하기에 비싼 자원**입니다.
  
### 스레드는 왜 비쌀까?
  
1. **생성 비용 : 커널 자원 할당과 시스템 콜 비용**
   - 스레드를 생성하기 위해서는,  cpu 흐름을 강제로 끊고 커널모드로 권한을 바꾸고 스레드 당 스택 메모리를 할당해야 합니다.
2. **관리 비용 : 컨텍스트 스위칭과 캐시 무효화 비용**
   - **컨텍스트 스위칭**은 스레드 간 전환하는 동작을 의미하며, 스레드 간 전환을 위해서는 현재 스레드 상태를 저장하고 다음 스레드 상태를 복원해야 합니다.
   - 컨텍스트 스위칭이 발생하면, cpu 캐시가 오염되기 때문에 캐시 히트율이 떨어져 **메모리 접근 지연**이 발생할 수 있습니다.
  
이러한 문제를 해결하기 위해 등장한 것이 GCD입니다.  

> *앞으로 GCD부터 현대 iOS 동시성 제어 구조까지 공부한 내용을 글로 작성해보고자 합니다.*
  
---
  
:::fold[키워드 정리 🧹]
##### 스레드
- **프로세스에서 실행되는 가장 작은 제어 흐름 단위**입니다.
- 프로세스에는 기본적으로 메인 스레드 하나가 존재합니다. 그리고 메인 스레드는 main() 함수와 같은 시작점부터 코드를 한줄씩 읽어 내려갑니다.
##### 프로세스
- 앱과 같은 **프로그램이 실행된 상태**로, OS 입장에서는 메모리 공간과 실행 컨텍스트를 할당받은 **실행 단위**입니다.
##### 커널
- **하드웨어에 직접 접근**할 수 있는 유일한 영역으로, **운영체제의 핵심 영역**입니다.
- CPU는 실행 모드에 따라 접근 권한이 달라지는데, 유저 모드와 커널 모드로 구성되며 하드웨어 접근 가능 여부에 차이가 있습니다.
  - **유저 모드** : 일반 앱 코드 실행
  - **커널 모드** : 하드웨어 제어, 메모리 맵 변경, 스레드 스케줄링
##### 시스템 콜
- 앱(유저모드)에서 커널에게 작업을 요청하기 위해 호출하는 동작입니다. (파일 읽기, 스레드 생성, 메모리 할당 등)
- 유저모드에서 호출 시 CPU는 유저 모드에서 커널 모드로 전환되고 커널 코드가 실행됩니다.
:::